<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0f">
    <title>Geo Master - Online Photo Contest</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <style>
        :root {
            /* Professional B&W Soft Theme */
            --bg-color: #0d0d0d;
            --surface-color: #1a1a1a;
            --surface-hover: #262626;
            --text-primary: #ededed;
            --text-secondary: #aaaaaa;
            --accent-color: #ffffff;
            --border-color: #333333;
            --glass-bg: rgba(26, 26, 26, 0.9);
            --glass-border: rgba(255, 255, 255, 0.1);

            /* Safe Areas */
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            width: 100%;
            height: 100dvh;
        }

        /* Map fixes */
        #map {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            filter: grayscale(100%) contrast(1.1);
            /* Soft B&W Map */
        }

        /* Screen Management */
        .screen {
            position: fixed;
            inset: 0;
            z-index: 10;
            display: flex;
            flex-direction: column;
            background: var(--bg-color);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease, transform 0.4s ease;
            transform: scale(0.98);
        }

        .screen.visible {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
        }

        .screen-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: calc(20px + var(--safe-top)) 24px calc(20px + var(--safe-bottom));
            max-width: 600px;
            width: 100%;
            margin: 0 auto;
            overflow-y: auto;
        }

        /* UI Components */
        button {
            font-family: inherit;
        }

        .btn {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 12px;
            width: 100%;
        }

        .btn:active {
            transform: scale(0.98);
            background: var(--surface-hover);
        }

        .btn.primary {
            background: var(--text-primary);
            color: var(--bg-color);
            border: none;
            font-weight: 600;
        }

        .btn.secondary {
            background: transparent;
            border: 1px solid var(--border-color);
        }

        .btn-icon-svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Typography */
        h1,
        h2,
        h3 {
            margin: 0;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .title-lg {
            font-size: 32px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 15px;
            margin-bottom: 40px;
        }

        .section-header {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin: 24px 0 12px;
            font-weight: 600;
        }

        /* Inputs */
        .input-group {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 14px 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .input-group input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 16px;
            width: 100%;
            outline: none;
            font-family: inherit;
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        /* Avatar Selector */
        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        .avatar-option {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .avatar-option.selected {
            background: var(--text-primary);
            border-color: var(--text-primary);
            transform: scale(1.1);
        }

        /* Room List */
        .room-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .room-card {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 16px;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .room-name {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .room-meta {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .join-btn-small {
            background: var(--text-primary);
            color: var(--bg-color);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Camera Frame Overlay */
        .camera-overlay {
            position: fixed;
            inset: 0;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .camera-overlay.visible {
            opacity: 1;
        }

        .camera-frame {
            width: 85vw;
            aspect-ratio: 4/5;
            /* Professional Ratio */
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            box-shadow: 0 0 0 100vh rgba(0, 0, 0, 0.8);
            /* Mask */
            position: relative;
        }

        .camera-frame::after {
            /* Crosshair center */
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 20px;
        }

        /* Voting Gallery - Fullscreen & Professional */
        .voting-gallery {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2px;
            width: 100%;
            padding: 0;
            margin-top: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .vote-card {
            position: relative;
            background: #000;
            aspect-ratio: 4/5;
            overflow: hidden;
            cursor: pointer;
        }

        .vote-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .vote-card:hover img {
            opacity: 1;
        }

        .vote-card.selected img {
            opacity: 1;
        }

        .vote-card.selected {
            border: 2px solid #fff;
            z-index: 2;
        }

        .vote-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            font-size: 12px;
            color: #fff;
        }

        /* Modern Chat (Hidden by default, overlays nicely) */
        .chat-modern-toggle {
            position: fixed;
            bottom: calc(24px + var(--safe-bottom));
            right: 24px;
            width: 56px;
            height: 56px;
            background: var(--text-primary);
            color: var(--bg-color);
            border-radius: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 40;
            cursor: pointer;
        }

        .chat-modern-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 85dvh;
            background: var(--bg-color);
            z-index: 50;
            border-radius: 24px 24px 0 0;
            transform: translateY(105%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--border-color);
            padding-bottom: var(--safe-bottom);
        }

        .chat-modern-overlay.visible {
            transform: translateY(0);
        }

        .chat-header-modern {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .chat-messages-modern {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .msg-bubble {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 14px;
            line-height: 1.4;
            background: var(--surface-color);
            align-self: flex-start;
        }

        .msg-bubble.me {
            background: var(--text-primary);
            color: var(--bg-color);
            align-self: flex-end;
        }

        .msg-meta {
            font-size: 11px;
            margin-bottom: 4px;
            opacity: 0.6;
            display: block;
        }

        .chat-input-area {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-color);
            display: flex;
            gap: 10px;
        }

        /* Voice Chat Indicator */
        .voice-btn {
            background: var(--surface-color);
            color: var(--text-primary);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .voice-btn.active {
            background: #fff;
            color: #000;
        }

        /* Stats row on welcome */
        .stats-row {
            display: flex;
            gap: 40px;
            margin-bottom: 40px;
        }

        .stat-box {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 5px;
        }

        /* Icon Utility */
        .icon {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* Online Game UI re-style */
        .online-game-ui {
            position: fixed;
            inset: 0;
            z-index: 50;
            display: flex;
            flex-direction: column;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .online-game-ui.visible {
            opacity: 1;
            pointer-events: none;
        }

        .online-top-bar {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            padding-top: 50px;
            width: 100%;
        }

        .online-timer-box {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 30px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 32px;
            font-weight: 700;
            font-family: monospace;
            text-align: center;
            color: #fff;
        }

        .bottom-controls {
            margin-top: auto;
            padding-bottom: 50px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .capture-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #fff;
            border: 4px solid rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            transition: transform 0.1s;
        }

        .capture-btn:active {
            transform: scale(0.95);
        }

        .capture-hint {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
        }

        /* Misc */
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 44px;
            height: 44px;
            z-index: 100;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-primary);
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface-color);
            padding: 12px 24px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .toast.visible {
            opacity: 1;
        }

        /* Loading */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s infinite linear;
            margin-bottom: 20px;
        }

        /* Friends & Social */
        .menu-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            width: 100%;
        }

        .main-btn {
            background: var(--text-primary);
            color: #000;
            border: none;
            padding: 18px;
            border-radius: 16px;
            font-weight: 700;
            width: 100%;
            font-size: 16px;
            cursor: pointer;
        }

        .secondary-btn {
            background: transparent;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 18px;
            border-radius: 16px;
            font-weight: 600;
            width: 100%;
            font-size: 16px;
            cursor: pointer;
        }

        .countdown-number {
            font-size: 15vw;
            font-weight: 900;
        }

        /* Photo Captured Preview */
        .photo-captured {
            position: absolute;
            bottom: 140px;
            right: 20px;
            width: 120px;
            height: 150px;
            background: #fff;
            padding: 5px;
            transform: rotate(-5deg);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 60;
            display: none;
            /* Hidden by default until captured */
        }

        .photo-captured.show {
            display: block;
        }

        .photo-captured img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <!-- WELCOME SCREEN -->
    <div class="screen visible" id="welcomeScreen">
        <div class="screen-content" style="max-width: 600px;">
            <div style="text-align: center; margin-bottom: 30px;">
                <h1 class="welcome-title">GeoMaster</h1>
                <p class="welcome-subtitle">Explore. Capture. Compete.</p>
            </div>

            <!-- Main Actions -->
            <div style="display: flex; flex-direction: column; gap: 12px; width: 100%; margin-bottom: 24px;">
                <button class="btn primary" id="quickPlayBtn" style="height: 64px; font-size: 18px;">
                    Play Now
                </button>

                <div style="display: flex; gap: 12px;">
                    <button class="btn secondary" id="onlineBtn" style="flex: 1;">
                        Custom Game
                    </button>
                    <button class="btn secondary" id="soloBtnRedirect" style="flex: 1;">
                        Solo Practice
                    </button>
                </div>
            </div>

            <!-- Social & Rooms -->
            <div style="width: 100%; display: flex; flex-direction: column; gap: 16px;">
                <div style="display: flex; gap: 12px;">
                    <button class="btn secondary" id="friendsBtn" style="flex: 1;">Friends</button>
                    <button class="btn secondary" id="globalChatBtn" style="flex: 1;">Global Chat</button>
                </div>

                <!-- Open Rooms Section -->
                <div
                    style="background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 16px; min-height: 150px;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <span
                            style="font-size: 13px; font-weight: 600; text-transform: uppercase; color: var(--text-secondary);">Open
                            Rooms</span>
                        <div id="loadingRooms" class="loading-spinner"
                            style="width: 16px; height: 16px; border-width: 2px; margin: 0; display: none;"></div>
                    </div>

                    <div id="roomListContainer" class="room-list">
                        <div style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 13px;">
                            Searching for active rooms...
                        </div>
                    </div>
                </div>
            </div>

            <div style="margin-top: 24px; display: flex; gap: 20px; justify-content: center;">
                <div class="stat-box">
                    <div class="stat-value" id="onlineCount">0</div>
                    <div class="stat-label">Online</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="gamesPlayed">0</div>
                    <div class="stat-label">Games</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ONLINE MENU SCREEN -->
    <div class="screen" id="onlineMenuScreen">
        <button class="back-btn" id="onlineMenuBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="section-title">Online Mode</div>

            <input type="text" class="name-input" id="playerNameInput" placeholder="Your nickname..." maxlength="20">

            <div class="avatar-selector" id="avatarSelector">
                <div class="avatar-option selected" data-avatar="üêº">üêº</div>
                <div class="avatar-option" data-avatar="ü¶ä">ü¶ä</div>
                <div class="avatar-option" data-avatar="üêØ">üêØ</div>
                <div class="avatar-option" data-avatar="üê∏">üê∏</div>
                <div class="avatar-option" data-avatar="üêô">üêô</div>
            </div>

            <button class="secondary-btn no-anim" id="googleLoginBtn"
                style="margin-top: 0; margin-bottom: 16px; width: 100%; display: flex; align-items: center; justify-content: center; gap: 10px;">
                <svg width="18" height="18" viewBox="0 0 24 24">
                    <path fill="#4285F4"
                        d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                    <path fill="#34A853"
                        d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                    <path fill="#FBBC05"
                        d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                    <path fill="#EA4335"
                        d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                </svg>
                Sign in with Google
            </button>
            <button class="secondary-btn no-anim" id="googleLogoutBtn"
                style="margin-top: 0; margin-bottom: 16px; width: 100%; display: none;">Sign Out</button>

            <button class="main-btn no-anim" id="createRoomBtn" style="margin-bottom: 12px;">Create Room</button>
            <button class="secondary-btn no-anim" id="joinRoomBtn">Join Room</button>
        </div>
    </div>

    <!-- JOIN ROOM SCREEN -->
    <div class="screen" id="joinRoomScreen">
        <button class="back-btn" id="joinRoomBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="section-title">Join Room</div>

            <input type="text" class="join-input" id="roomCodeInput" placeholder="CODE" maxlength="6">

            <button class="main-btn no-anim" id="joinRoomConfirmBtn">Join</button>
        </div>
    </div>

    <!-- LOBBY SCREEN -->
    <div class="screen" id="lobbyScreen">
        <button class="back-btn" id="lobbyBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="lobby-title">Game Lobby</div>
            <div class="lobby-code" id="lobbyCode">ABCD12</div>
            <button class="copy-code-btn" id="copyCodeBtn">Copy Code</button>

            <div class="players-list" id="playersList"></div>

            <div class="waiting-text" id="waitingText">Waiting for players...</div>

            <button class="main-btn no-anim" id="startOnlineGameBtn">Start Game</button>
        </div>
    </div>

    <!-- COUNTDOWN SCREEN -->
    <div class="screen" id="countdownScreen">
        <div class="screen-content">
            <div class="countdown-number" id="countdownNumber">3</div>
            <div class="countdown-text">Get Ready</div>
        </div>
    </div>

    <!-- ONLINE GAME UI -->
    <div class="online-game-ui" id="onlineGameUI">
        <div class="online-top-bar">
            <div class="online-timer-box" id="onlineTimerDisplay">01:00</div>
            <div class="online-status" id="onlineStatus">Find the best view!</div>
        </div>

        <div class="spacer"></div>

        <div class="photo-captured" id="photoCaptured" style="display: none;">
            <img id="capturedPreview" src="" alt="Captured">
        </div>

        <div class="bottom-controls">
            <button class="capture-btn" id="captureBtn">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10" />
                </svg>
            </button>
            <div class="capture-hint" id="captureHint">Press to capture the best view</div>
        </div>

        <button class="icon-btn quit quit-online-btn" id="quitOnlineBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M18 6L6 18M6 6l12 12" />
            </svg>
        </button>
    </div>

    <!-- VOTING SCREEN -->
    <div class="screen" id="votingScreen">
        <div class="screen-content" style="max-width: 600px;">
            <div class="voting-title">Vote for the Best Photo!</div>
            <div class="voting-timer" id="votingTimer">10</div>

            <div class="photos-grid" id="photosGrid"></div>
        </div>
    </div>

    <!-- WINNER SCREEN -->
    <div class="screen" id="winnerScreen">
        <div class="screen-content">
            <div class="winner-crown">üëë</div>
            <div class="winner-title">Winner!</div>
            <div class="winner-name" id="winnerName">Player Name</div>

            <div class="winner-photo" id="winnerPhotoContainer">
                <img id="winnerPhoto" src="" alt="Winner">
            </div>

            <div class="winner-votes" id="winnerVotes">5 votes</div>

            <button class="main-btn no-anim" id="playAgainOnlineBtn">Play Again</button>
            <button class="secondary-btn no-anim" id="backToLobbyBtn">Back to Lobby</button>
        </div>
    </div>

    <!-- LOADING SCREEN -->
    <div class="screen" id="loadingScreen">
        <div class="screen-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loadingText">Connecting...</div>
        </div>
    </div>

    <!-- TOAST -->
    <div class="toast" id="toast"></div>

    <!-- =============== SOLO MODE SCREENS =============== -->

    <!-- GAME TYPE SCREEN -->
    <div class="screen" id="gameTypeScreen">
        <button class="back-btn" id="gameTypeBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="section-title">What do you want to learn?</div>
            <div class="type-options">
                <button class="type-btn" data-type="countries">
                    <span class="type-icon">üåç</span>
                    <span class="type-name">Countries</span>
                    <span class="type-desc">World nations</span>
                </button>
                <button class="type-btn" data-type="cities">
                    <span class="type-icon">üèôÔ∏è</span>
                    <span class="type-name">Cities</span>
                    <span class="type-desc">Select a country</span>
                </button>
            </div>
        </div>
    </div>

    <!-- COUNTRY SELECT SCREEN -->
    <div class="screen" id="countrySelectScreen">
        <button class="back-btn" id="countrySelectBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="section-title">Select Country</div>
            <input type="text" class="country-search" id="countrySearchInput" placeholder="Search country..."
                autocomplete="off">
            <div class="country-list" id="countryList"></div>
        </div>
    </div>

    <!-- MODE SCREEN -->
    <div class="screen" id="modeScreen">
        <button class="back-btn" id="modeBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="section-title">Select Mode</div>
            <div class="mode-list">
                <div class="mode-item" data-mode="type">
                    <div class="mode-header">
                        <span class="mode-name">Learn</span>
                        <div class="mode-difficulty">
                            <span class="diff-dot active"></span>
                            <span class="diff-dot"></span>
                            <span class="diff-dot"></span>
                            <span class="diff-dot"></span>
                        </div>
                    </div>
                    <p class="mode-desc" id="modeDescType">Region is shown on map. Type its name to learn.</p>
                </div>
                <div class="mode-item" data-mode="click">
                    <div class="mode-header">
                        <span class="mode-name">Find & Click</span>
                        <div class="mode-difficulty">
                            <span class="diff-dot active"></span>
                            <span class="diff-dot active"></span>
                            <span class="diff-dot"></span>
                            <span class="diff-dot"></span>
                        </div>
                    </div>
                    <p class="mode-desc" id="modeDescClick">Find the region on map and click it.</p>
                </div>
                <div class="mode-item" data-mode="choice">
                    <div class="mode-header">
                        <span class="mode-name">Quiz</span>
                        <div class="mode-difficulty">
                            <span class="diff-dot active"></span>
                            <span class="diff-dot active"></span>
                            <span class="diff-dot active"></span>
                            <span class="diff-dot"></span>
                        </div>
                    </div>
                    <p class="mode-desc" id="modeDescChoice">Region shown, pick correct name from 4 choices.</p>
                </div>
                <div class="mode-item" data-mode="hard">
                    <div class="mode-header">
                        <span class="mode-name">Expert</span>
                        <div class="mode-difficulty">
                            <span class="diff-dot active"></span>
                            <span class="diff-dot active"></span>
                            <span class="diff-dot active"></span>
                            <span class="diff-dot active"></span>
                        </div>
                    </div>
                    <p class="mode-desc" id="modeDescHard">Find & click with penalty. Wrong click = -1 point.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- TIME SCREEN -->
    <div class="screen" id="timeScreen">
        <button class="back-btn" id="timeBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="section-title">Select Duration</div>
            <div class="time-options">
                <button class="time-btn" data-time="60">
                    <span class="time-value">1</span>
                    <span class="time-label">Min</span>
                </button>
                <button class="time-btn selected" data-time="120">
                    <span class="time-value">2</span>
                    <span class="time-label">Min</span>
                </button>
                <button class="time-btn" data-time="180">
                    <span class="time-value">3</span>
                    <span class="time-label">Min</span>
                </button>
            </div>
            <button class="continue-btn" id="startSoloGameBtn">Continue</button>
        </div>
    </div>

    <!-- SETTINGS SCREEN -->
    <div class="screen" id="settingsScreen">
        <button class="back-btn" id="settingsBackBtn">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
        </button>
        <div class="screen-content">
            <div class="section-title">Settings</div>
            <div class="settings-section">
                <div class="settings-label">Map Theme</div>
                <div class="theme-grid">
                    <button class="theme-btn" data-theme="dark">Dark</button>
                    <button class="theme-btn" data-theme="light">Light</button>
                    <button class="theme-btn selected" data-theme="satellite">Satellite</button>
                    <button class="theme-btn" data-theme="terrain">Terrain</button>
                </div>
            </div>
            <div class="settings-section">
                <div class="settings-label">Data</div>
                <button class="reset-btn" id="resetScoresBtn">Reset All Scores</button>
            </div>
        </div>
    </div>

    <!-- SOLO GAME UI -->
    <div class="solo-game-ui" id="soloGameUI">
        <div class="top-bar">
            <div class="timer-box">
                <div class="timer-display" id="soloTimerDisplay">02:00</div>
            </div>
            <div class="score-display" id="scoreDisplay">Score: 0</div>
        </div>

        <div class="spacer"></div>

        <div class="bottom-panel">
            <div class="main-panel">
                <div class="question-box">
                    <div class="question-label" id="questionLabel">Question</div>
                    <div class="question-text" id="questionText">Loading...</div>
                    <div class="question-hint" id="questionHint">Please wait</div>

                    <div class="input-container" id="inputContainer">
                        <input type="text" id="answerInput" placeholder="Type name..." autocomplete="off"
                            autocorrect="off" autocapitalize="off">
                        <button class="submit-btn" id="submitBtn">Go</button>
                    </div>

                    <div class="choices-container" id="choicesContainer"></div>
                </div>

                <div class="action-buttons">
                    <button class="icon-btn active-scale" id="skipBtn" title="Skip">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M5 4l10 8-10 8V4zM19 5v14" />
                        </svg>
                    </button>
                    <button class="icon-btn active-scale" id="fitBtn" title="Reset View">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                            <path d="M3 3v5h5" />
                        </svg>
                    </button>
                    <button class="icon-btn quit active-scale" id="quitSoloBtn" title="Quit">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M18 6L6 18M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- SOLO RESULT SCREEN -->
    <div class="screen" id="soloResultScreen">
        <div class="screen-content">
            <div class="result-icon" id="resultIcon" style="font-size: 72px; margin-bottom: 20px;">&#127942;</div>
            <h2 class="result-title" id="resultTitle" style="font-size: 36px; font-weight: 700; margin-bottom: 8px;">
                Game Over</h2>
            <p class="result-subtitle" id="resultSubtitle"
                style="font-size: 14px; color: var(--text-secondary); margin-bottom: 40px;">Great performance!</p>

            <div class="result-stats">
                <div class="result-stat">
                    <div class="value" id="finalScore">0</div>
                    <div class="label">Score</div>
                </div>
                <div class="result-stat">
                    <div class="value" id="finalQuestions">0</div>
                    <div class="label">Questions</div>
                </div>
            </div>

            <div class="result-buttons">
                <button class="main-btn no-anim" id="playAgainSoloBtn">Play Again</button>
                <button class="secondary-btn no-anim" id="soloMenuBtn">Main Menu</button>
            </div>
        </div>
    </div>


    <!-- CHAT OVERLAY -->
    <div class="chat-toggle-btn" id="chatToggleBtn">üí¨</div>
    <div class="chat-overlay" id="chatOverlay">
        <div class="chat-header">
            <span>Team Chat</span>
            <span class="chat-close" id="chatCloseBtn">‚úï</span>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-footer">
            <div class="emoji-bar">
                <button class="emoji-btn">üòÇ</button>
                <button class="emoji-btn">üëç</button>
                <button class="emoji-btn">‚ù§Ô∏è</button>
                <button class="emoji-btn">üî•</button>
                <button class="emoji-btn">üòÆ</button>
                <button class="emoji-btn">üëè</button>
            </div>
            <div class="chat-input-row">
                <input type="text" id="chatInput" placeholder="Message..." autocomplete="off">
                <button id="sendChatBtn">‚û§</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import { getDatabase, ref, set, get, push, onValue, update, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyCbBh9ulc4_tds31MsDbiSgaHPUU3l0Qx4",
            authDomain: "maps-52b00.firebaseapp.com",
            projectId: "maps-52b00",
            storageBucket: "maps-52b00.firebasestorage.app",
            messagingSenderId: "485125559932",
            appId: "1:485125559932:web:7d304f3f2cda4ef4c21bf9",
            measurementId: "G-YHHXDYCCG7",
            databaseURL: "https://maps-52b00-default-rtdb.europe-west1.firebasedatabase.app"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        const provider = new GoogleAuthProvider();
        provider.setCustomParameters({ prompt: "select_account" });

        // DOM Elements
        const $ = id => document.getElementById(id);

        const welcomeScreen = $("welcomeScreen");
        const onlineMenuScreen = $("onlineMenuScreen");
        const joinRoomScreen = $("joinRoomScreen");
        const lobbyScreen = $("lobbyScreen");
        const countdownScreen = $("countdownScreen");
        const onlineGameUI = $("onlineGameUI");
        const votingScreen = $("votingScreen");
        const winnerScreen = $("winnerScreen");
        const loadingScreen = $("loadingScreen");
        const toast = $("toast");

        // Chat Elements
        const chatToggleBtn = $("chatToggleBtn");
        const chatOverlay = $("chatOverlay");
        const chatCloseBtn = $("chatCloseBtn");
        const chatMessages = $("chatMessages");
        const chatInput = $("chatInput");
        const sendChatBtn = $("sendChatBtn");

        // Map Setup
        const map = L.map("map", {
            zoomControl: false,
            worldCopyJump: true,
            minZoom: 2,
            maxZoom: 18
        }).setView([41.0082, 28.9784], 12); // Istanbul

        L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
            maxZoom: 19
        }).addTo(map);

        // Game State
        let currentRoomId = null;
        let currentPlayerId = null;
        let playerName = "";
        let isHost = false;
        let uid = null;
        let gameTimer = null;
        let votingTimer = null;
        let capturedPhoto = null;
        let hasVoted = false;
        let roomListener = null;

        // Google Login
        async function loginWithGoogle() {
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Popup failed, trying redirect:", error);
                // iOS popup sorunu icin redirect kullan
                signInWithRedirect(auth, provider);
            }
        }

        // Google Logout
        async function logout() {
            if (currentRoomId) {
                await leaveRoom();
            }
            try {
                await signOut(auth);
                showToast("Signed out", "success");
            } catch (error) {
                console.error("Logout error:", error);
            }
        }

        // Check redirect result on page load
        getRedirectResult(auth).then((result) => {
            if (result && result.user) {
                showToast("Signed in!", "success");
            }
        }).catch((error) => {
            console.error("Redirect result error:", error);
        });

        // Presence system
        let presenceRef = null;

        function setupPresence(user) {
            if (!user) return;

            const userName = user.displayName || "Anonymous";
            presenceRef = ref(db, `presence/${user.uid}`);

            // Connection state reference
            const connectedRef = ref(db, ".info/connected");

            onValue(connectedRef, (snapshot) => {
                if (snapshot.val() === true) {
                    // Set online status
                    set(presenceRef, {
                        uid: user.uid,
                        name: userName.slice(0, 20),
                        roomId: currentRoomId || "lobby",
                        online: true,
                        lastSeen: Date.now()
                    });

                    // When disconnected, update status
                    onDisconnect(presenceRef).set({
                        uid: user.uid,
                        name: userName.slice(0, 20),
                        roomId: "lobby",
                        online: false,
                        lastSeen: Date.now()
                    });
                }
            });
        }

        function updatePresenceRoom(roomId) {
            if (!presenceRef || !auth.currentUser) return;
            update(presenceRef, {
                roomId: roomId || "lobby",
                lastSeen: Date.now()
            });
        }

        // Listen to online users count
        function listenToOnlineUsers() {
            const presenceListRef = ref(db, "presence");
            onValue(presenceListRef, (snapshot) => {
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    const onlineUsers = Object.values(data).filter(u => u.online === true);
                    $("onlineCount").textContent = onlineUsers.length;
                } else {
                    $("onlineCount").textContent = "0";
                }
            });
        }

        // Start listening to online users
        listenToOnlineUsers();

        // Auth state listener
        onAuthStateChanged(auth, (user) => {
            if (user) {
                uid = user.uid;
                currentPlayerId = uid;

                // Auto-fill name input
                if (user.displayName) {
                    $("playerNameInput").value = user.displayName.slice(0, 20);
                }

                // Toggle buttons
                $("googleLoginBtn").style.display = "none";
                $("googleLogoutBtn").style.display = "block";

                // Setup presence
                setupPresence(user);
            } else {
                uid = null;
                currentPlayerId = null;
                presenceRef = null;

                // Toggle buttons
                $("googleLoginBtn").style.display = "flex";
                $("googleLogoutBtn").style.display = "none";
            }
        });

        // Generate Room Code
        function generateRoomCode() {
            const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
            let code = "";
            for (let i = 0; i < 6; i++) {
                code += chars[Math.floor(Math.random() * chars.length)];
            }
            return code;
        }

        // Generate Player ID
        function generatePlayerId() {
            return "player_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
        }

        // Show Toast
        function showToast(msg, type = "") {
            toast.textContent = msg;
            toast.className = "toast visible " + type;
            setTimeout(() => toast.className = "toast", 2000);
        }

        // Show Screen - Updated with Dashboard Polling
        function showScreen(screen) {
            document.querySelectorAll(".screen").forEach(s => {
                s.classList.remove("visible");
            });
            if (screen) screen.classList.add("visible");

            // Dashboard Logic
            if (screen === welcomeScreen) {
                startRoomPolling();
            } else {
                stopRoomPolling();
            }
        }

        // ==========================================
        // DASHBOARD LOGIC
        // ==========================================
        let roomPollInterval = null;

        function startRoomPolling() {
            refreshRoomList();
            if (!roomPollInterval) roomPollInterval = setInterval(refreshRoomList, 5000);
        }

        function stopRoomPolling() {
            if (roomPollInterval) {
                clearInterval(roomPollInterval);
                roomPollInterval = null;
            }
        }

        async function refreshRoomList() {
            const listContainer = $("roomListContainer");
            if (!listContainer) return;

            const loading = $("loadingRooms");
            if (loading) loading.style.display = "block";

            try {
                const roomsRef = ref(db, "rooms");
                const snapshot = await get(roomsRef);

                if (loading) loading.style.display = "none";
                listContainer.innerHTML = "";

                let found = false;
                if (snapshot.exists()) {
                    const rooms = snapshot.val();
                    Object.entries(rooms).forEach(([id, room]) => {
                        // Filter for waiting rooms
                        if (room.status === "waiting" && room.players) {
                            found = true;
                            const count = Object.keys(room.players).length;
                            const hostName = Object.values(room.players).find(p => p.isHost)?.name || "Unknown";

                            const el = document.createElement("div");
                            el.className = "room-card";
                            el.innerHTML = `
                                <div class="room-info">
                                    <div class="room-name">${hostName}'s Room</div>
                                    <div class="room-meta">Code: ${id} ‚Ä¢ ${count}/20 Players</div>
                                </div>
                                <button class="join-btn-small" onclick="window.joinRoomById('${id}')">Join</button>
                            `;
                            listContainer.appendChild(el);
                        }
                    });
                }

                if (!found) {
                    listContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 13px;">No active rooms. Create one to start!</div>';
                }
            } catch (e) {
                console.error("Error fetching rooms:", e);
                if (loading) loading.style.display = "none";
            }
        }

        async function quickJoin() {
            showScreen(loadingScreen);
            $("loadingText").textContent = "Finding match...";

            const roomsRef = ref(db, "rooms");
            const snapshot = await get(roomsRef);

            if (snapshot.exists()) {
                const rooms = snapshot.val();
                // Find first available waiting room
                const available = Object.entries(rooms).find(([id, room]) => room.status === "waiting");
                if (available) {
                    window.joinRoomById(available[0]);
                } else {
                    createRoom(); // Auto create
                }
            } else {
                createRoom();
            }
        }

        // Global helper for the room list button
        window.joinRoomById = (id) => {
            $("roomCodeInput").value = id;
            showScreen(joinRoomScreen);
        };

        // Format Time
        function formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
        }

        // Initialize Avatar
        let currentAvatar = "üêº";
        document.querySelectorAll(".avatar-option").forEach(opt => {
            opt.addEventListener("click", () => {
                document.querySelectorAll(".avatar-option").forEach(o => o.classList.remove("selected"));
                opt.classList.add("selected");
                currentAvatar = opt.dataset.avatar;
            });
        });

        // Create Room
        async function createRoom() {
            // Guest handling
            if (!currentPlayerId) {
                currentPlayerId = "guest_" + Date.now() + "_" + Math.random().toString(36).substr(2, 5);
            }

            const inputName = $("playerNameInput").value.trim();
            playerName = inputName || (auth.currentUser?.displayName?.slice(0, 20)) || "Guest " + currentPlayerId.substr(-4);

            showScreen(loadingScreen);
            $("loadingText").textContent = "Creating room...";

            const roomCode = generateRoomCode();
            currentRoomId = roomCode;
            isHost = true;

            const roomRef = ref(db, `rooms/${roomCode}`);

            try {
                await set(roomRef, {
                    code: roomCode,
                    hostId: currentPlayerId,
                    status: "waiting",
                    createdAt: Date.now(),
                    gameTime: 60,
                    votingTime: 10,
                    players: {
                        [currentPlayerId]: {
                            name: playerName,
                            avatar: currentAvatar,
                            isHost: true,
                            photo: null,
                            votes: 0,
                            hasVoted: false,
                            joinedAt: Date.now()
                        }
                    }
                });

                // Set up disconnect handler
                const playerRef = ref(db, `rooms/${roomCode}/players/${currentPlayerId}`);
                onDisconnect(playerRef).remove();

                // Update presence
                updatePresenceRoom(roomCode);

                enterLobby(roomCode);
            } catch (error) {
                console.error(error);
                showToast("Failed to create room", "error");
                showScreen(onlineMenuScreen);
            }
        }

        // Join Room
        async function joinRoom() {
            // Guest handling
            if (!currentPlayerId) {
                currentPlayerId = "guest_" + Date.now() + "_" + Math.random().toString(36).substr(2, 5);
            }

            const roomCode = $("roomCodeInput").value.trim().toUpperCase();
            if (!roomCode || roomCode.length !== 6) {
                showToast("Enter valid room code!", "error");
                return;
            }

            const inputName = $("playerNameInput").value.trim();
            playerName = inputName || (auth.currentUser?.displayName?.slice(0, 20)) || "Guest " + currentPlayerId.substr(-4);

            showScreen(loadingScreen);
            $("loadingText").textContent = "Joining room...";

            currentRoomId = roomCode;
            isHost = false;

            const roomRef = ref(db, `rooms/${roomCode}`);

            try {
                const snapshot = await get(roomRef);
                if (!snapshot.exists()) {
                    showToast("Room not found!", "error");
                    showScreen(joinRoomScreen);
                    return;
                }

                const roomData = snapshot.val();
                if (roomData.status !== "waiting") {
                    showToast("Game already started!", "error");
                    showScreen(joinRoomScreen);
                    return;
                }

                // Add player
                const playerRef = ref(db, `rooms/${roomCode}/players/${currentPlayerId}`);
                await set(playerRef, {
                    name: playerName,
                    avatar: currentAvatar,
                    isHost: false,
                    photo: null,
                    votes: 0,
                    hasVoted: false,
                    joinedAt: Date.now()
                });

                // Set up disconnect handler
                onDisconnect(playerRef).remove();

                // Update presence
                updatePresenceRoom(roomCode);

                enterLobby(roomCode);
            } catch (error) {
                console.error(error);
                showToast("Failed to join room", "error");
                showScreen(joinRoomScreen);
            }
        }

        // Enter Lobby
        function enterLobby(roomCode) {
            $("lobbyCode").textContent = roomCode;
            showScreen(lobbyScreen);

            // Show/hide start button based on host
            $("startOnlineGameBtn").style.display = isHost ? "block" : "none";

            // Listen to room changes
            const roomRef = ref(db, `rooms/${roomCode}`);

            if (roomListener) {
                roomListener();
            }

            setupChat(`rooms/${roomCode}/chat`, true); // Initialize Chat

            roomListener = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    showToast("Room closed", "error");
                    leaveRoom();
                    return;
                }

                const roomData = snapshot.val();

                // Update players list
                renderPlayersList(roomData.players);

                // Handle game state changes
                if (roomData.status === "countdown") {
                    startCountdown(roomData);
                } else if (roomData.status === "playing") {
                    if (!onlineGameUI.classList.contains("visible")) {
                        startOnlineGame(roomData);
                    }
                } else if (roomData.status === "voting") {
                    startVoting(roomData);
                } else if (roomData.status === "results") {
                    showResults(roomData);
                }
            });
        }

        // Render Players List
        function renderPlayersList(players) {
            const list = $("playersList");
            list.innerHTML = "";

            if (!players) return;

            const playerCount = Object.keys(players).length;
            $("waitingText").textContent = `${playerCount} player${playerCount > 1 ? "s" : ""} in lobby`;

            Object.entries(players).forEach(([id, player]) => {
                const item = document.createElement("div");
                item.className = "player-item";

                const displayAvatar = player.avatar || player.name.charAt(0).toUpperCase();

                item.innerHTML = `
          <div class="player-avatar">${displayAvatar}</div>
          <div class="player-name">${player.name}</div>
          ${player.isHost ? '<div class="player-host">HOST</div>' : ''}
        `;

                list.appendChild(item);
            });
        }

        // Start Game (Host only)
        async function startGameFromLobby() {
            if (!isHost) return;

            const roomRef = ref(db, `rooms/${currentRoomId}`);
            await update(roomRef, {
                status: "countdown",
                countdownStart: Date.now()
            });
        }

        // Start Countdown
        function startCountdown(roomData) {
            showScreen(countdownScreen);
            onlineGameUI.classList.remove("visible");

            let count = 3;
            const countdownNumber = $("countdownNumber");
            countdownNumber.textContent = count;
            countdownNumber.style.animation = "none";
            void countdownNumber.offsetWidth;
            countdownNumber.style.animation = "countPop 0.9s cubic-bezier(0.16, 1, 0.3, 1) forwards";

            const interval = setInterval(async () => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                    countdownNumber.style.animation = "none";
                    void countdownNumber.offsetWidth;
                    countdownNumber.style.animation = "countPop 0.9s cubic-bezier(0.16, 1, 0.3, 1) forwards";
                } else {
                    clearInterval(interval);

                    // Only host updates status
                    if (isHost) {
                        const roomRef = ref(db, `rooms/${currentRoomId}`);
                        await update(roomRef, {
                            status: "playing",
                            gameStartTime: Date.now()
                        });
                    }
                }
            }, 1000);
        }

        // Start Online Game
        function startOnlineGame(roomData) {
            showScreen(null);
            onlineGameUI.classList.add("visible");

            capturedPhoto = null;
            $("photoCaptured").style.display = "none";
            $("captureBtn").disabled = false;
            hasVoted = false;

            // Random location
            const locations = [
                [41.0082, 28.9784, 14], // Istanbul
                [48.8566, 2.3522, 14], // Paris
                [40.7128, -74.0060, 14], // New York
                [35.6762, 139.6503, 14], // Tokyo
                [51.5074, -0.1278, 14], // London
                [-33.8688, 151.2093, 14], // Sydney
                [55.7558, 37.6173, 14], // Moscow
                [25.2048, 55.2708, 14], // Dubai
                [52.5200, 13.4050, 14], // Berlin
                [41.9028, 12.4964, 14], // Rome
            ];

            const randomLoc = locations[Math.floor(Math.random() * locations.length)];
            map.setView([randomLoc[0], randomLoc[1]], randomLoc[2]);

            // Start timer
            let timeLeft = roomData.gameTime || 60;
            $("onlineTimerDisplay").textContent = formatTime(timeLeft);
            $("onlineTimerDisplay").classList.remove("warning");

            if (gameTimer) clearInterval(gameTimer);

            gameTimer = setInterval(async () => {
                timeLeft--;
                $("onlineTimerDisplay").textContent = formatTime(timeLeft);

                if (timeLeft <= 10) {
                    $("onlineTimerDisplay").classList.add("warning");
                }

                if (timeLeft <= 0) {
                    clearInterval(gameTimer);

                    // Only host updates status
                    if (isHost) {
                        const roomRef = ref(db, `rooms/${currentRoomId}`);
                        await update(roomRef, {
                            status: "voting",
                            votingStartTime: Date.now()
                        });
                    }
                }
            }, 1000);
        }

        // Capture Photo
        async function capturePhoto() {
            $("captureBtn").disabled = true;
            $("captureHint").textContent = "Capturing...";

            try {
                // Hide UI temporarily
                onlineGameUI.style.opacity = "0";

                await new Promise(r => setTimeout(r, 100));

                const canvas = await html2canvas(document.getElementById("map"), {
                    useCORS: true,
                    allowTaint: true,
                    logging: false
                });

                onlineGameUI.style.opacity = "1";

                capturedPhoto = canvas.toDataURL("image/jpeg", 0.6);

                // Show preview
                $("capturedPreview").src = capturedPhoto;
                $("photoCaptured").style.display = "block";

                // Save to Firebase
                const photoRef = ref(db, `rooms/${currentRoomId}/players/${currentPlayerId}/photo`);
                await set(photoRef, capturedPhoto);

                $("captureHint").textContent = "Photo captured! You can capture again.";
                $("captureBtn").disabled = false;

                showToast("Photo captured!", "success");
            } catch (error) {
                console.error(error);
                onlineGameUI.style.opacity = "1";
                $("captureHint").textContent = "Failed. Try again.";
                $("captureBtn").disabled = false;
                showToast("Capture failed", "error");
            }
        }

        // Start Voting
        function startVoting(roomData) {
            if (gameTimer) clearInterval(gameTimer);

            showScreen(votingScreen);
            onlineGameUI.classList.remove("visible");

            const grid = $("photosGrid");
            grid.innerHTML = "";

            if (!roomData.players) return;

            // Render all photos
            Object.entries(roomData.players).forEach(([id, player]) => {
                if (!player.photo) return;

                const card = document.createElement("div");
                card.className = "photo-card";
                card.dataset.playerId = id;

                card.innerHTML = `
          <img src="${player.photo}" alt="${player.name}">
          <div class="photo-card-info">
            <div class="photo-card-name">${player.name}</div>
            <div class="photo-card-votes">${player.votes || 0} votes</div>
          </div>
        `;

                if (id !== currentPlayerId) {
                    card.addEventListener("click", () => voteForPhoto(id));
                } else {
                    card.style.opacity = "0.6";
                    card.style.cursor = "not-allowed";
                }

                grid.appendChild(card);
            });

            // Start voting timer
            let votingTimeLeft = roomData.votingTime || 10;
            $("votingTimer").textContent = votingTimeLeft;

            if (votingTimer) clearInterval(votingTimer);

            votingTimer = setInterval(async () => {
                votingTimeLeft--;
                $("votingTimer").textContent = votingTimeLeft;

                if (votingTimeLeft <= 0) {
                    clearInterval(votingTimer);

                    // Only host updates status
                    if (isHost) {
                        const roomRef = ref(db, `rooms/${currentRoomId}`);
                        await update(roomRef, {
                            status: "results"
                        });
                    }
                }
            }, 1000);
        }

        // Vote for Photo
        async function voteForPhoto(playerId) {
            if (hasVoted) {
                showToast("Already voted!", "error");
                return;
            }

            hasVoted = true;

            // Update UI
            document.querySelectorAll(".photo-card").forEach(card => {
                card.classList.remove("selected");
                if (card.dataset.playerId === playerId) {
                    card.classList.add("selected");
                }
            });

            // Update vote count in Firebase
            const playerRef = ref(db, `rooms/${currentRoomId}/players/${playerId}`);
            const snapshot = await get(playerRef);
            if (snapshot.exists()) {
                const currentVotes = snapshot.val().votes || 0;
                await update(playerRef, { votes: currentVotes + 1 });
            }

            // Mark as voted
            const myRef = ref(db, `rooms/${currentRoomId}/players/${currentPlayerId}`);
            await update(myRef, { hasVoted: true });

            showToast("Vote submitted!", "success");
        }

        // Show Results
        function showResults(roomData) {
            if (votingTimer) clearInterval(votingTimer);

            showScreen(winnerScreen);

            if (!roomData.players) return;

            // Find winner
            let winner = null;
            let maxVotes = -1;

            Object.entries(roomData.players).forEach(([id, player]) => {
                if ((player.votes || 0) > maxVotes) {
                    maxVotes = player.votes || 0;
                    winner = { id, ...player };
                }
            });

            if (winner && winner.photo) {
                $("winnerName").textContent = winner.name;
                $("winnerPhoto").src = winner.photo;
                $("winnerVotes").textContent = `${maxVotes} vote${maxVotes !== 1 ? "s" : ""}`;
                $("winnerPhotoContainer").style.display = "block";
            } else {
                $("winnerName").textContent = "No winner";
                $("winnerPhotoContainer").style.display = "none";
                $("winnerVotes").textContent = "No photos submitted";
            }
        }

        // Leave Room
        async function leaveRoom() {
            if (roomListener) {
                roomListener();
                roomListener = null;
            }

            if (gameTimer) clearInterval(gameTimer);
            if (votingTimer) clearInterval(votingTimer);

            if (currentRoomId && currentPlayerId) {
                try {
                    const playerRef = ref(db, `rooms/${currentRoomId}/players/${currentPlayerId}`);
                    await remove(playerRef);

                    // If host leaves and room is waiting, delete room
                    if (isHost) {
                        const roomRef = ref(db, `rooms/${currentRoomId}`);
                        const snapshot = await get(roomRef);
                        if (snapshot.exists()) {
                            const players = snapshot.val().players;
                            if (!players || Object.keys(players).length === 0) {
                                await remove(roomRef);
                            }
                        }
                    }
                } catch (e) {
                    console.error(e);
                }
            }

            // Update presence back to lobby
            updatePresenceRoom("lobby");

            currentRoomId = null;
            currentPlayerId = uid; // Keep uid for presence
            isHost = false;
            capturedPhoto = null;
            hasVoted = false;

            onlineGameUI.classList.remove("visible");
            cleanupChat();
            showScreen(welcomeScreen);
        }

        // Play Again
        async function playAgain() {
            if (!currentRoomId) return;

            // Reset player data
            const playerRef = ref(db, `rooms/${currentRoomId}/players/${currentPlayerId}`);
            await update(playerRef, {
                photo: null,
                votes: 0,
                hasVoted: false
            });

            // Only host resets game
            if (isHost) {
                const roomRef = ref(db, `rooms/${currentRoomId}`);

                // Reset all players
                const snapshot = await get(roomRef);
                if (snapshot.exists()) {
                    const players = snapshot.val().players;
                    const updates = {};
                    Object.keys(players).forEach(id => {
                        updates[`players/${id}/photo`] = null;
                        updates[`players/${id}/votes`] = 0;
                        updates[`players/${id}/hasVoted`] = false;
                    });
                    updates.status = "countdown";
                    updates.countdownStart = Date.now();

                    await update(roomRef, updates);
                }
            }
        }

        // Back to Lobby
        async function backToLobby() {
            if (!currentRoomId) return;

            // Reset player data
            const playerRef = ref(db, `rooms/${currentRoomId}/players/${currentPlayerId}`);
            await update(playerRef, {
                photo: null,
                votes: 0,
                hasVoted: false
            });

            // Only host resets game
            if (isHost) {
                const roomRef = ref(db, `rooms/${currentRoomId}`);

                const snapshot = await get(roomRef);
                if (snapshot.exists()) {
                    const players = snapshot.val().players;
                    const updates = {};
                    Object.keys(players).forEach(id => {
                        updates[`players/${id}/photo`] = null;
                        updates[`players/${id}/votes`] = 0;
                        updates[`players/${id}/hasVoted`] = false;
                    });
                    updates.status = "waiting";

                    await update(roomRef, updates);
                }
            }

            capturedPhoto = null;
            hasVoted = false;
            showScreen(lobbyScreen);
        }

        // ==========================================
        // CHAT LOGIC
        // ==========================================
        let chatRef = null;
        let currentChatPath = null;

        function setupChat(path, isGame = true) {
            cleanupChat();
            currentChatPath = path;
            chatRef = ref(db, path);

            // Listen
            onValue(chatRef, (snapshot) => {
                const msgs = snapshot.val();
                chatMessages.innerHTML = "";
                if (msgs) {
                    Object.values(msgs).forEach(msg => appendMessage(msg));
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            });

            if (isGame) {
                chatToggleBtn.style.display = "flex";
                chatToggleBtn.onclick = () => {
                    chatOverlay.classList.add("visible");
                    chatToggleBtn.style.display = "none";
                    if (chatInput) chatInput.focus();
                };
            } else {
                // Global Chat: Open immediately
                chatOverlay.classList.add("visible");
                $("chatMessages").innerHTML = '<div style="text-align:center; opacity:0.5; font-size:12px; margin-top:10px;">Welcome to Global Chat</div>';
            }

            chatCloseBtn.onclick = () => {
                chatOverlay.classList.remove("visible");
                if (isGame) {
                    chatToggleBtn.style.display = "flex";
                } else {
                    cleanupChat(); // Disconnect global chat when closed
                }
            };
        }

        async function sendChatMessage() {
            const text = chatInput.value.trim();
            if (!text || !currentChatPath) return;

            const chatRoomRef = ref(db, currentChatPath);
            await push(chatRoomRef, {
                senderId: currentPlayerId,
                senderName: playerName,
                text: text,
                time: Date.now()
            });

            chatInput.value = "";
        }

        function appendMessage(msg) {
            const bubble = document.createElement("div");
            bubble.className = `message-bubble ${msg.senderId === currentPlayerId ? "me" : ""}`;

            if (msg.senderId !== currentPlayerId) {
                const author = document.createElement("div");
                author.className = "message-author";
                author.textContent = msg.senderName;
                bubble.appendChild(author);
            }

            const text = document.createElement("div");
            text.textContent = msg.text;
            bubble.appendChild(text);

            chatMessages.appendChild(bubble);
        }

        function cleanupChat() {
            chatToggleBtn.style.display = "none";
            chatOverlay.classList.remove("visible");
            chatRef = null;
        }

        // Event Listeners
        // Event Listeners
        $("quickPlayBtn").addEventListener("click", quickJoin);

        $("onlineBtn").addEventListener("click", () => {
            showScreen(onlineMenuScreen);
        });

        $("soloBtnRedirect").addEventListener("click", () => {
            window.location.href = "https://yusufertek.com.tr/map";
        });

        $("friendsBtn").addEventListener("click", () => {
            showToast("Friend system coming soon!", "success");
        });

        $("globalChatBtn").addEventListener("click", () => {
            setupChat("global-chat", false);
        });

        $("onlineMenuBackBtn").addEventListener("click", () => {
            showScreen(welcomeScreen);
        });

        $("googleLoginBtn").addEventListener("click", loginWithGoogle);
        $("googleLogoutBtn").addEventListener("click", logout);

        $("createRoomBtn").addEventListener("click", createRoom);

        $("joinRoomBtn").addEventListener("click", () => {
            playerName = $("playerNameInput").value.trim();
            if (!playerName) {
                showToast("Enter your name first!", "error");
                return;
            }
            showScreen(joinRoomScreen);
        });

        $("joinRoomBackBtn").addEventListener("click", () => {
            showScreen(onlineMenuScreen);
        });

        $("joinRoomConfirmBtn").addEventListener("click", joinRoom);

        $("roomCodeInput").addEventListener("input", (e) => {
            e.target.value = e.target.value.toUpperCase();
        });

        $("lobbyBackBtn").addEventListener("click", leaveRoom);

        $("copyCodeBtn").addEventListener("click", () => {
            navigator.clipboard.writeText(currentRoomId).then(() => {
                showToast("Code copied!", "success");
            });
        });

        $("startOnlineGameBtn").addEventListener("click", startGameFromLobby);

        $("captureBtn").addEventListener("click", capturePhoto);

        $("quitOnlineBtn").addEventListener("click", leaveRoom);

        $("playAgainOnlineBtn").addEventListener("click", playAgain);

        $("backToLobbyBtn").addEventListener("click", backToLobby);

        // Chat Listeners
        if (sendChatBtn) sendChatBtn.addEventListener("click", sendChatMessage);
        if (chatInput) chatInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") sendChatMessage();
        });

        document.querySelectorAll(".emoji-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                chatInput.value += btn.textContent;
                chatInput.focus();
            });
        });

        // Update online count
        const roomsRef = ref(db, "rooms");
        onValue(roomsRef, (snapshot) => {
            let onlineCount = 0;
            let gamesCount = 0;

            if (snapshot.exists()) {
                const rooms = snapshot.val();
                Object.values(rooms).forEach(room => {
                    if (room.players) {
                        onlineCount += Object.keys(room.players).length;
                    }
                    gamesCount++;
                });
            }

            $("onlineCount").textContent = onlineCount;
            $("gamesPlayed").textContent = gamesCount;
        });
        // ==========================================
        // SOLO MODE LOGIC
        // ==========================================

        // CONFIG & DATA
        const GEOJSON_URL = "./countries.geojson";
        const NAME_FIELDS = ["ADMIN", "NAME", "NAME_EN", "NAME_LONG", "SOVEREIGNT", "FORMAL_EN", "BRK_NAME", "NAME_TR", "NAME_TUR"];
        const OVERPASS_API = "https://overpass-api.de/api/interpreter";

        const CITY_COUNTRIES = [
            { code: "TR", name: "Turkey", flag: "üáπüá∑" },
            { code: "DE", name: "Germany", flag: "üá©üá™" },
            { code: "FR", name: "France", flag: "üá´üá∑" },
            { code: "IT", name: "Italy", flag: "üáÆüáπ" },
            { code: "ES", name: "Spain", flag: "üá™üá∏" },
            { code: "GB", name: "United Kingdom", flag: "üá¨üáß" },
            { code: "NL", name: "Netherlands", flag: "üá≥üá±" },
            { code: "BE", name: "Belgium", flag: "üáßüá™" },
            { code: "US", name: "United States", flag: "üá∫üá∏" },
            { code: "RU", name: "Russia", flag: "üá∑üá∫" },
            { code: "JP", name: "Japan", flag: "üáØüáµ" },
            { code: "CN", name: "China", flag: "üá®üá≥" },
            { code: "BR", name: "Brazil", flag: "üáßüá∑" },
            { code: "IN", name: "India", flag: "üáÆüá≥" },
            { code: "AU", name: "Australia", flag: "üá¶üá∫" }
        ];

        const MAP_THEMES = {
            dark: "https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png",
            light: "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
            satellite: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            terrain: "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png"
        };

        const THEME_STYLES = {
            dark: {
                default: { color: "rgba(255,255,255,0.15)", weight: 1, fillColor: "rgba(255,255,255,0.03)", fillOpacity: 1 },
                focus: { color: "rgba(255,255,255,0.7)", weight: 2, fillColor: "rgba(255,255,255,0.15)", fillOpacity: 1 },
                correct: { color: "rgba(34,197,94,0.8)", weight: 2, fillColor: "rgba(34,197,94,0.3)", fillOpacity: 1 },
                wrong: { color: "rgba(239,68,68,0.8)", weight: 2, fillColor: "rgba(239,68,68,0.3)", fillOpacity: 1 }
            },
            light: {
                default: { color: "rgba(0,0,0,0.2)", weight: 1, fillColor: "rgba(0,0,0,0.05)", fillOpacity: 1 },
                focus: { color: "rgba(0,0,0,0.6)", weight: 2, fillColor: "rgba(0,0,0,0.1)", fillOpacity: 1 },
                correct: { color: "rgba(34,197,94,0.9)", weight: 2, fillColor: "rgba(34,197,94,0.35)", fillOpacity: 1 },
                wrong: { color: "rgba(239,68,68,0.9)", weight: 2, fillColor: "rgba(239,68,68,0.35)", fillOpacity: 1 }
            },
            satellite: {
                default: { color: "rgba(255,255,255,0.5)", weight: 1.5, fillColor: "rgba(255,255,255,0.08)", fillOpacity: 1 },
                focus: { color: "#ffffff", weight: 3, fillColor: "rgba(255,255,255,0.25)", fillOpacity: 1 },
                correct: { color: "#22c55e", weight: 3, fillColor: "rgba(34,197,94,0.4)", fillOpacity: 1 },
                wrong: { color: "#ef4444", weight: 3, fillColor: "rgba(239,68,68,0.4)", fillOpacity: 1 }
            },
            terrain: {
                default: { color: "rgba(100,100,100,0.3)", weight: 1, fillColor: "rgba(100,100,100,0.05)", fillOpacity: 1 },
                focus: { color: "rgba(50,50,50,0.8)", weight: 2, fillColor: "rgba(50,50,50,0.15)", fillOpacity: 1 },
                correct: { color: "rgba(34,197,94,0.9)", weight: 2, fillColor: "rgba(34,197,94,0.3)", fillOpacity: 1 },
                wrong: { color: "rgba(239,68,68,0.9)", weight: 2, fillColor: "rgba(239,68,68,0.3)", fillOpacity: 1 }
            }
        };

        // SOLO DOM ELEMENTS
        const gameTypeScreen = $("gameTypeScreen");
        const countrySelectScreen = $("countrySelectScreen");
        const modeScreen = $("modeScreen");
        const timeScreen = $("timeScreen");
        const settingsScreen = $("settingsScreen");
        const soloGameUI = $("soloGameUI");
        const soloResultScreen = $("soloResultScreen");

        const soloTimerDisplay = $("soloTimerDisplay");
        const scoreDisplay = $("scoreDisplay");
        const questionLabel = $("questionLabel");
        const questionText = $("questionText");
        const questionHint = $("questionHint");
        const inputContainer = $("inputContainer");
        const answerInput = $("answerInput");
        const submitBtn = $("submitBtn");
        const choicesContainer = $("choicesContainer");

        // SOLO STATE
        const MODE = { TYPE: "type", CLICK: "click", CHOICE: "choice", HARD: "hard" };
        const GAME_TYPE = { COUNTRIES: "countries", CITIES: "cities" };

        let selectedGameType = GAME_TYPE.COUNTRIES;
        let selectedCountryCode = null;
        let selectedMode = null;
        let selectedTime = 120;
        let currentMode = null;
        let soloRunning = false;
        let soloScore = 0;
        let soloQCount = 0;
        let soloTimeLeft = 120;
        let soloTimerHandle = null;
        let currentRegion = null;
        let regions = [];
        let allBounds = null;
        let geoLayer = null;
        let citiesCache = {};
        let currentTileLayer = null;
        let currentTheme = localStorage.getItem("mapTheme") || "satellite";
        let highScore = parseInt(localStorage.getItem("highScore") || "0");

        // MAP THEME FUNCTIONS
        function getStyles() {
            return THEME_STYLES[currentTheme] || THEME_STYLES.satellite;
        }

        function setMapTheme(theme) {
            currentTheme = theme;
            localStorage.setItem("mapTheme", theme);

            // Update tile layer
            if (currentTileLayer) map.removeLayer(currentTileLayer);

            currentTileLayer = L.tileLayer(MAP_THEMES[theme], {
                maxZoom: 19,
                attribution: ''
            }).addTo(map);

            // Update UI
            document.querySelectorAll(".theme-btn").forEach(btn => {
                btn.classList.toggle("selected", btn.dataset.theme === theme);
            });

            // Update region styles
            if (regions.length) resetAllStyles();
        }

        // Initialize Theme (default)
        // setMapTheme(currentTheme); <--- Called when entering Solo Mode

        function resetAllStyles() {
            regions.forEach(r => {
                if (r.layer) r.layer.setStyle(r.correct ? getStyles().correct : getStyles().default);
            });
        }

        function applyStyle(r, styleName) {
            if (r && r.layer) {
                r.layer.setStyle(getStyles()[styleName]);
            }
        }

        function flashWrong(layer) {
            layer.setStyle(getStyles().wrong);
            setTimeout(() => layer.setStyle(getStyles().default), 400);
        }

        function normalizeText(s) {
            return String(s || "").trim().toLocaleLowerCase("tr-TR").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/ƒ±/g, "i").replace(/\s+/g, " ");
        }

        function getNames(props) {
            const names = [];
            for (const k of NAME_FIELDS) {
                if (props && props[k]) names.push(String(props[k]));
            }
            const seen = new Set();
            return names.filter(n => {
                const x = normalizeText(n);
                if (!x || seen.has(x)) return false;
                seen.add(x);
                return true;
            });
        }

        function getDisplayName(r) {
            return r.primaryName || r.names[0] || "Unknown";
        }

        function fitWorld() {
            if (allBounds) map.fitBounds(allBounds.pad(0.1));
        }

        function updateHUD() {
            soloTimerDisplay.textContent = formatTime(soloTimeLeft);
            scoreDisplay.textContent = `Score: ${soloScore}`;
            if (soloTimeLeft <= 10) soloTimerDisplay.classList.add("warning");
            else soloTimerDisplay.classList.remove("warning");
        }

        // GAME FLOW
        function startSoloGame() {
            currentMode = selectedMode;
            soloRunning = true;
            soloScore = 0;
            soloQCount = 0;
            currentRegion = null;

            regions.forEach(r => {
                r.correct = false;
                r.asked = false;
                applyStyle(r, "default");
            });

            showScreen(null);
            soloGameUI.classList.add("visible");
            fitWorld();

            startSoloTimer();
            setTimeout(newQuestion, 500);
        }

        function startSoloTimer() {
            soloTimeLeft = selectedTime;
            updateHUD();
            if (soloTimerHandle) clearInterval(soloTimerHandle);
            soloTimerHandle = setInterval(() => {
                if (!soloRunning) return;
                soloTimeLeft--;
                if (soloTimeLeft < 0) soloTimeLeft = 0;
                updateHUD();
                if (soloTimeLeft === 0) endSoloGame();
            }, 1000);
        }

        function endSoloGame() {
            soloRunning = false;
            if (soloTimerHandle) clearInterval(soloTimerHandle);

            soloGameUI.classList.remove("visible");
            showScreen(soloResultScreen);

            $("finalScore").textContent = soloScore;
            $("finalQuestions").textContent = soloQCount;

            // Score saving logic
            const scoreKey = selectedGameType === GAME_TYPE.COUNTRIES ? "highScore" : `highScore_${selectedCountryCode}`;
            const best = parseInt(localStorage.getItem(scoreKey) || "0");

            if (soloScore > best) {
                localStorage.setItem(scoreKey, soloScore);
                $("resultTitle").textContent = "New Record!";
            } else {
                $("resultTitle").textContent = "Game Over";
            }
        }

        function quitSoloToMenu() {
            soloRunning = false;
            if (soloTimerHandle) clearInterval(soloTimerHandle);
            soloGameUI.classList.remove("visible");

            // Clean up map layers if leaving cities mode
            if (selectedGameType === GAME_TYPE.CITIES) {
                loadGeoJSON(); // Reload world
            }

            updatePresenceRoom("lobby");
            showScreen(welcomeScreen);
        }

        function pickNextRegion() {
            let pool = regions.filter(r => !r.asked);
            if (pool.length === 0) {
                regions.forEach(r => r.asked = false);
                pool = regions.slice();
            }
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function newQuestion() {
            if (!soloRunning || !regions.length) return;

            currentRegion = pickNextRegion();
            currentRegion.asked = true;
            soloQCount++;
            updateHUD();
            resetAllStyles();

            inputContainer.classList.remove("visible");
            choicesContainer.classList.remove("visible");
            choicesContainer.innerHTML = "";
            answerInput.value = "";

            const name = getDisplayName(currentRegion);
            const regionWord = selectedGameType === GAME_TYPE.COUNTRIES ? "COUNTRY" : "CITY";

            if (currentMode === MODE.TYPE) {
                applyStyle(currentRegion, "focus");
                map.fitBounds(currentRegion.layer.getBounds().pad(0.3), { animate: true });
                questionText.textContent = `WHAT ${regionWord} IS THIS?`;
                inputContainer.classList.add("visible");
                setTimeout(() => answerInput.focus(), 100);
            } else if (currentMode === MODE.CLICK || currentMode === MODE.HARD) {
                questionText.textContent = name;
            } else if (currentMode === MODE.CHOICE) {
                applyStyle(currentRegion, "focus");
                map.fitBounds(currentRegion.layer.getBounds().pad(0.3), { animate: true });
                questionText.textContent = `WHAT ${regionWord} IS THIS?`;

                // Generates choices
                const pool = regions.filter(r => r !== currentRegion);
                const wrongs = [];
                while (wrongs.length < 3 && pool.length) {
                    wrongs.push(pool.splice(Math.floor(Math.random() * pool.length), 1)[0]);
                }
                const options = [{ label: name, correct: true }, ...wrongs.map(w => ({ label: getDisplayName(w), correct: false }))];
                options.sort(() => Math.random() - 0.5);

                options.forEach(opt => {
                    const btn = document.createElement("button");
                    btn.className = "choice-btn";
                    btn.textContent = opt.label;
                    btn.onclick = () => handleChoiceAnswer(opt.correct, btn);
                    choicesContainer.appendChild(btn);
                });
                choicesContainer.classList.add("visible");
            }
        }

        function handleChoiceAnswer(isCorrect, btn) {
            if (!soloRunning) return;
            if (isCorrect) {
                btn.classList.add("correct");
                soloScore++;
                currentRegion.correct = true;
                applyStyle(currentRegion, "correct");
                showToast("Correct!", "success");
                setTimeout(newQuestion, 600);
            } else {
                btn.classList.add("wrong");
                showToast("Wrong!", "error");
                setTimeout(() => btn.classList.remove("wrong"), 400);
            }
            updateHUD();
        }

        function checkTypedAnswer() {
            if (!soloRunning || !currentRegion) return;
            const typed = normalizeText(answerInput.value);
            const match = currentRegion.names.some(n => normalizeText(n) === typed);
            if (match) {
                soloScore++;
                currentRegion.correct = true;
                applyStyle(currentRegion, "correct");
                showToast("Correct!", "success");
                setTimeout(newQuestion, 600);
            } else {
                showToast("Try again", "error");
                answerInput.select();
            }
            updateHUD();
        }

        function handleMapClick(r) {
            if (!soloRunning) return;
            if (currentMode !== MODE.CLICK && currentMode !== MODE.HARD) return;

            if (r === currentRegion) {
                soloScore++;
                r.correct = true;
                applyStyle(r, "correct");
                showToast("Correct!", "success");
                setTimeout(newQuestion, 600);
            } else {
                if (currentMode === MODE.HARD) {
                    soloScore = Math.max(0, soloScore - 1);
                    showToast("-1 Point", "error");
                } else {
                    showToast("Wrong", "error");
                }
                flashWrong(r.layer);
            }
            updateHUD();
        }

        // LOAD DATA
        async function loadGeoJSON() {
            try {
                const res = await fetch(GEOJSON_URL);
                if (!res.ok) throw new Error("GeoJSON error");
                const data = await res.json();

                if (geoLayer) map.removeLayer(geoLayer);
                regions = [];

                geoLayer = L.geoJSON(data, {
                    style: () => getStyles().default,
                    onEachFeature: (feature, layer) => {
                        const names = getNames(feature.properties);
                        if (!names.length) return;
                        const obj = { layer, names, primaryName: names[0], correct: false, asked: false };
                        regions.push(obj);
                        layer.on("click", () => handleMapClick(obj)); // Solo click handler
                    }
                }).addTo(map);

                allBounds = geoLayer.getBounds();
                if (selectedGameType === GAME_TYPE.COUNTRIES) fitWorld(); // Only fit if not in online mode... tricky.
                // Actually, only add layer if in Solo Mode? 
                // We'll manage visibility when entering/exiting modes.

            } catch (err) {
                console.error(err);
            }
        }

        async function loadCitiesForCountry(code) {
            const adminLevel = code === "TR" ? "4" : "4"; // Simplified for now
            const query = `[out:json][timeout:90];area["ISO3166-1"="${code}"]->.searchArea;(relation["boundary"="administrative"]["admin_level"="${adminLevel}"](area.searchArea););out body;>;out skel qt;`;

            const response = await fetch(OVERPASS_API, { method: "POST", body: "data=" + encodeURIComponent(query) });
            const data = await response.json();
            const geojson = osmToGeoJSON(data); // Need to define this function too!

            if (geoLayer) map.removeLayer(geoLayer);
            regions = [];

            geoLayer = L.geoJSON(geojson, {
                style: () => getStyles().default,
                onEachFeature: (feature, layer) => {
                    const obj = { layer, names: [feature.properties.name], primaryName: feature.properties.name, correct: false, asked: false };
                    regions.push(obj);
                    layer.on("click", () => handleMapClick(obj));
                }
            }).addTo(map);

            allBounds = geoLayer.getBounds();
            fitWorld();
        }

        // HELPER GEO FUNCTIONS (Reduced for brevity, assuming standard impl)
        function osmToGeoJSON(osmData) {
            const nodes = {};
            const ways = {};
            const features = [];

            osmData.elements.forEach(el => {
                if (el.type === "node") {
                    nodes[el.id] = [el.lon, el.lat];
                }
            });

            osmData.elements.forEach(el => {
                if (el.type === "way") {
                    ways[el.id] = el.nodes.map(nid => nodes[nid]).filter(Boolean);
                }
            });

            osmData.elements.forEach(el => {
                if (el.type === "relation" && el.tags) {
                    const name = el.tags.name || el.tags["name:en"] || el.tags["name:tr"];
                    if (!name) return;

                    const outerRings = [];
                    const innerRings = [];

                    el.members.forEach(member => {
                        if (member.type === "way" && ways[member.ref]) {
                            const coords = ways[member.ref];
                            if (coords.length > 2) {
                                if (member.role === "inner") {
                                    innerRings.push(coords);
                                } else {
                                    outerRings.push(coords);
                                }
                            }
                        }
                    });

                    if (outerRings.length > 0) {
                        const mergedOuter = mergeRings(outerRings);

                        mergedOuter.forEach(ring => {
                            const polygon = [ring];
                            innerRings.forEach(inner => {
                                polygon.push(inner);
                            });

                            features.push({
                                type: "Feature",
                                properties: {
                                    name: name,
                                    admin_level: el.tags.admin_level
                                },
                                geometry: {
                                    type: "Polygon",
                                    coordinates: polygon
                                }
                            });
                        });
                    }
                }
            });

            return {
                type: "FeatureCollection",
                features: features
            };
        }

        function mergeRings(rings) {
            if (rings.length === 0) return [];

            const result = [];
            const used = new Set();

            for (let i = 0; i < rings.length; i++) {
                if (used.has(i)) continue;

                let current = [...rings[i]];
                used.add(i);
                let merged = true;

                while (merged) {
                    merged = false;
                    for (let j = 0; j < rings.length; j++) {
                        if (used.has(j)) continue;

                        const ring = rings[j];
                        const first = current[0];
                        const last = current[current.length - 1];
                        const ringFirst = ring[0];
                        const ringLast = ring[ring.length - 1];

                        if (coordsEqual(last, ringFirst)) {
                            current = current.concat(ring.slice(1));
                            used.add(j);
                            merged = true;
                        } else if (coordsEqual(last, ringLast)) {
                            current = current.concat(ring.slice(0, -1).reverse());
                            used.add(j);
                            merged = true;
                        } else if (coordsEqual(first, ringLast)) {
                            current = ring.concat(current.slice(1));
                            used.add(j);
                            merged = true;
                        } else if (coordsEqual(first, ringFirst)) {
                            current = ring.slice().reverse().concat(current.slice(1));
                            used.add(j);
                            merged = true;
                        }
                    }
                }

                result.push(current);
            }

            return result;
        }

        function coordsEqual(a, b) {
            if (!a || !b) return false;
            return Math.abs(a[0] - b[0]) < 0.0001 && Math.abs(a[1] - b[1]) < 0.0001;
        }

        // EVENT LISTENERS
        $("soloBtn").addEventListener("click", () => {
            window.location.href = "https://yusufertek.com.tr/map";
        });

        document.querySelectorAll(".theme-btn").forEach(btn => {
            btn.addEventListener("click", () => setMapTheme(btn.dataset.theme));
        });

        $("onlineBtn").addEventListener("click", () => {
            // Prepare Online Mode
            if (geoLayer) map.removeLayer(geoLayer);
            map.invalidateSize();
            showScreen(onlineMenuScreen);
        });

        // Initial setup
        // Don't loadGeoJSON immediately, wait for user to click Solo.


    </script>
</body>

</html>
